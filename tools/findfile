#!/usr/bin/env perl
##
## findfile   by D. S. "Pat" Patterson   1994-05-12
##
##   2015-01-20 - Added -x option.
##   2015-01-21 - Added -V option.
##   2015-02-23 - Added $FINDFILE_ARGS, -z option.
##   2017-12-21 - Fix error msgs generated by unreadable directories.
##   2018-03-21 - Rewrite arg processing, refactor arg list, add debugging.
##   2018-04-15 - Make -v mention excluded files and directories.
##   2018-05-20 - Make -r '' work properly.
##
## NAME
##   findfile - Wildcard filename search program.  Matches filenames
##   against RegExpr in current or deeper subdirectories.
##
##   * Combo Unix/Linux/Windows version *
##
## DESCRIPTION
##   findfile is similar to find but with simpler syntax for routine
##   searches and more powerful options for more complex searches.  It can
##   also limit the depth of search to avoid unnecessary traversal of deep
##   subdirectories.
##
##   In shell-style  search  expressions,  /? + */  are treated as
##   /.? .+ .*/,  other nonalphanumerics are treated as literals,
##   and expressions are assumed to be right & left-justified.
##
##   findfile distinguishes between directory and file name searches.  In
##   verbose mode, findfile will display the directory nesting structure of
##   found files, as well as whether they are text or non-text files.
##
## SYNTAX
##   findfile ["fileNamePattern"] [options...]
##
## OPTIONS
##
##   -a Alphabetize (sort) file listing before searching.
##
##   -c Colorize file name matches in verbose output.
##
##   -d Directories only are to be displayed.
##
##   -D Dry-run replacements (display but don't actually execute
##      proposed changes).
##
##   -e File search pattern is an extended regular expression
##      (SED- or PERL-style.  Default is shell-style).
##
##   -f Files (non-directories) only are to be displayed.
##
##   -F Forces processing of backup files (*,n*), and the normally excluded
##      directories .backup, .git, and .svn.
##
##   -h Show this help page.
##
##   -i Ignore case during search.
##
##   -l <N>  Levels of directories to process.  Don't descend deeper than
##      N directory levels (default: no limit).
##
##   -L Follow (descend into) soft-linked directories.
##      (warning: infinite loops are possible in this mode)
##
##   -r <newFileNamePattern>  Replacement filename pattern.
##      (can use $1, $2, ... from search pattern)
##      Without -x: Invokes system command "move $fileName $newFileName"
##      With    -x: -x "shellCommand" is invoked, where
##                  "fileName" may be referenced as $0 and
##                  "newFileName" may be referenced as $1 in the
##                  shellCommand argument.
##      - Note 1:
##          Assumes (and sets) -e flag. Search pattern must be type regex.
##      - Note 2:
##          When a file or directory is matched, the current working dir
##          is the local directory containing the matched files.
##      - Note 3:
##          Suggest using -D to review the proposed script actions before
##          actually executing.
##
##   -s <filename-search-pattern>  File name pattern to search for.
##
##   -v verbose mode (directory tree style) t, b following filenames
##      indicates text or binary.
##
##   -V <N>  Turn on debug mode level "N".  N is the bitwise OR of:
##           1 - ad-hoc debugging
##           2 - function tracing
##           4 - built-in debug printing
##
##   -w Search for whole word matches for file name pattern.
##      (Note: do not use ^ or $ anchors in pattern with this switch).
##
##   -x <Expr>  Exclude files/directories matching "Expr".
##
##   -X <shell-command>  On fileName match, invoke shell command.
##
##      - Note 1: * * *
##          Assumes (and sets) -e flag.  Search pattern *must* be
##          type regexp.
##
##      - Note 2:
##          When a file or directory is matched, the current working dir
##          is the local directory containing the matched files.
##
##      - Note 3:
##          Replace any {/s} parameter with the actual filename (minus
##          the relative path) of the current found file.
##
##          Replace any {/r} parameter with the replacement filename (minus
##          the relative path) of the current found file, (assuming -r
##          was used, otherwise this parameter will be empty).
##
##          Replace any {/p} parameter with the actual relative path and
##          filename of the current found file;
##
##      - Note 4:
##          Suggest using -D to review the proposed script actions before
##          actually executing.
##
##   -z Ignore settings in $FINDFILE_ARGS.
##
## ENVIRONMENT VARIABLES
##   $FINDFILE_ARGS may be used to set arguments to be used every time.
##   It can be manually overridden with the -z flag.
##
## NOTES
##   Quotes around file name expressions are required if not simple text.
##
## EXAMPLES
##   findfile           # Find all files & dirs in current tree.
##
##   findfile dogs      # Find all files & dirs named 'dogs' in current tree.
##   findfile -s dogs   # Find all files & dirs named 'dogs' in current tree.
##
##   findfile dogs -e   # Find all files & dirs containing the string 'dogs' in current tree.
##
##   findfile dogs -f   # Find all files named 'dogs' in current tree.
##   findfile dogs -d   # Find all dirs  named 'dogs' in current tree.
##
##   findfile -v        # Find all files in current tree (verbose/tree-style).
##
##   findfile "*.C"   # Find all files ending with ".C".
##
##   findfile "^.*.C$" -e # (same as above, ERE style)
##
##   findfile -d      # Find all dirs in current tree.
##
##   findfile -l 3    # Find all files in 1st 3 levels of current tree.
##
##   findfile "(.*)\.foo" -r "$1\.bar"   # Wildcard file rename.
##
##   findfile foo -r bar                 # Wildcard file rename.
##                                       # (foo anywhere in file name)
##
##   findfile "((.*)\.foo)" -r "move $1 $2.bar" -x       # explicit shell cmd
##
##   findfile "GP.+\.RAW" -x "copy $0 C:\Temp\myNewPath" # explicit shell cmd
##
## SEE ALSO
##   findtext
##
## COPYRIGHT
##   Copyright (c) 1994 - 2018 by David S. "Pat" Patterson
##
## AUTHOR
##   David S. "Pat" Patterson
##
use strict;
use warnings;

use Getopt::Std;  # getopt()
use Cwd;          # cwd ()
use File::Copy;   # copy(), move()

# Turn on Autoflush:
#$| = 1;

our %ARG            = ();    # Arg hash table
our @BARGS          = ();    # Bare arg list
our $g_nlevels      = 9999;  # Max levels
our $g_shell_args   = 1;     # if true, process $FINDFILE_ARGS shell variable (if present)
our $g_re           = '';    # final search regular expression
our $g_repl         = '';    # final text replacement pattern
our $g_prt_df       = '';    # if true, print both matching directories and files
our $g_hlc_on       = '';    # highlight color on  command (xterm only)
our $g_hlc_off      = '';    # highlight color off command (xterm only)

#=========================================================================
# = function: main
#
sub main ()  # 04XX
{
    dbg::push (2, "main");

    if ($g_shell_args)
    {
        # Pre-concatenate shell $FINDFILE_ARGS fields to @ARGV:

        if (exists $ENV{'FINDFILE_ARGS'})
        {
            my $a = $ENV{'FINDFILE_ARGS'}  if (exists $ENV{'FINDFILE_ARGS'});

            my @a = split (/ +/, $a);

            dbg::print_list (2, "a", \@a);

            push (@a, @ARGV);

            @ARGV = @a;
        }
    }

    captureArgs ("acdDefFhil:Lr:s:vV:wx:X:z");

    # Deal with optional bare arg:
    if (! $ARG{'s'})
    {
        if ($BARGS[0])
        {
            $ARG{'s'} = $BARGS[0];
            splice (@BARGS, 0, 1, ());
        }
    }

    dbg::print_list (2, "BARGS l3", \@BARGS);
    dbg::print_hash (2, "ARG   l3", \%ARG);

    die "unexpected arg '$BARGS[0]'"  if ($BARGS[0]);


    # Do initial processing of the argument list:
    processArgs ();

    dbg::pop (2, "main");
}

#=========================================================================
# = function: captureArgs
#
# Description:
#   Capture all arguments from the command line (@ARGV) and place them in %ARG hash.
#   Initializes all optional args to ''.  Bare arguments are placed in @BARGS list.
#
#   All captured bare args are placed in a list in $ARG{'0'}.
#
# Usage:
#   $Options  Command line options token string
#
sub captureArgs ($)  # 06XX
{
    my ($Options) = @_;

    dbg::push (2, "captureArgs");

    dbg::print_list (2, "ARGV l1", \@ARGV);
    dbg::print_hash (2, "ARG  l1", \%ARG);

    # Initialize all options in %ARG:
    my @opts = split (//, $Options);

    for my $opt (@opts)
    {
        $ARG{$opt} = ''  if ($opt =~ /\w/);
    }

    do
    {
        # Parse the argument list and place the information into a global $g_ARGV_Hash:
        getopts ($Options, \%ARG);

        if ($ARGV[0])
        {
            push (@BARGS, $ARGV[0]);
            splice (@ARGV, 0, 1, ());
        }
    } while ($ARGV[0]);

    # Special Handling for -r to properly handle -r '':
    if ($g_repl)
    {
        $g_repl = $ARG{'r'};  # holds replacement pattern
        $ARG{'r'} = 1;        # used as flag
    }

    dbg::print_list (2, "ARGV  l2", \@ARGV);
    dbg::print_hash (2, "ARG   l2", \%ARG);
    dbg::print_list (2, "BARGS l2", \@BARGS);

    dbg::pop (2, "captureArgs");
}

#=========================================================================
# = function: processArgs
#
# Description:
#   Perform all initial processing on captured command line arguments.
#   Call mainLoop().
#
sub processArgs ()  # 08XX
{
    dbg::push (2, "processArgs");


    usage ()  if ($ARG{'h'});

    if ($g_nlevels < 1)
    {
        die ("Error: -l <N>: N must be 1 or greater");
    }

    # Set max level if specified:
    $g_nlevels = $ARG{'l'}  if ($ARG{'l'} ne '');

    # Assume search pattern is ERE if in search/replace or search/execute-command mode:
    $ARG{'e'} = 1           if ($ARG{'r'}  ||  $ARG{'X'});

    # If neither files or directories are specified, print both:
    #
    if ((! $ARG{'d'})  &&  (! $ARG{'f'}))
    {
        $g_prt_df = 1;
    }

    if ($ARG{'r'})
    {
        # Change backslashes in replacement parameter to double-backslashes:
        #
        $g_repl =~ s/\\/\|\|/g;
        $g_repl =~ s/\|\|/\\\\/g;
    }

    my $regexp = $ARG{'s'};

    if (! $regexp) # Default case is to show all files:
    {
        $regexp = '.+';
        $ARG{'e'}  = 1;
    }

    if ($ARG{'c'})
    {
        if (! $ARG{'v'})
        {
            die ("Error: -c requires -V");
        }

        # These are used to highlight file names in the verbose mode:
        $g_hlc_on  = "\x1b[38;5;226m";  # define highlight color on
        $g_hlc_off = "\x1b[0m";         # define highlight color off
    }

    mainLoop ($regexp);

    dbg::pop (2, "processArgs");
}

#=========================================================================
# = function: mainLoop
#
sub mainLoop ($)  # 12XX
{
    my ($regexp) = @_;

    dbg::push (2, "mainLoop");

    $g_re = $regexp;

    if ($ARG{'e'})   # sed style
    {
        if ($ARG{'w'})
        {
            # Make expression valid for whole words only:
            $g_re = '(^|[\W_])' . $g_re . '($|[\W_])';
        }
    }
    else      # shell style
    {
        # Place a \ in front of all non-alpha chars:
        $g_re =~ s/(\W)/\\$1/g;

        # Convert shell wildcards to ERE wildcards:
        $g_re =~ s/\\([*?+])/.$1/g;

        $g_re = '^' . $g_re . "\$";
    }

    if ($ARG{'v'})
    {
        print "Filename ERE = /$g_re/$ARG{'i'}\n";
    }

    study $g_re;


    my $pwd = cwd ();

    ckDir ('', '.', $pwd, 1);

    dbg::pop (2, "mainLoop");
}

#=========================================================================
# = function: ckDir
#
sub ckDir ($$$)  # 16XX
{
    dbg::push (2, "ckDir");

    my ($cur_dir_path, $cur_dir_name, $parent_dir, $level) = @_;

    my $fn;        # current file name
    my $indtxt;    # verbose indent text
    my $access;    # verbose access notation
    my $suffix;    # verbose suffix


    my @dirlist;
    my @dirlist0;


    my $currentdir = "$parent_dir/$cur_dir_name";

    if (! chdir ($cur_dir_name))
    {
        print "Error: Couldn't cd to $cur_dir_name!!!";

        return;  # SHOULD never get here, but...
    }

    my $new_dir_path = "$cur_dir_path$cur_dir_name/";


    opendir (DIR, ".");

    if ($ARG{'a'})  # alphabetize/sort file names first
    {
        @dirlist0 = readdir (DIR);

        @dirlist  = sort @dirlist0;
    }
    else
    {
        @dirlist  = readdir (DIR);
    }

    closedir (DIR);


    if ($ARG{'v'})
    {
        $indtxt = "| " x $level;
    }

    if ($g_prt_df  ||  $ARG{'f'})
    {
        foreach $fn (@dirlist) # first print files:
        {
            if (! -d $fn)
            {
                dbg::log (4, "'$fn' ~= /$g_re/ ?");

                if ($ARG{'i'} ? $fn =~ /$g_re/io : $fn =~ /$g_re/o)
                {
                    dbg::log (4, "'$fn' file name matched!");

                    # Process file if:
                    # - the "show all mode" flag is set, -or-
                    # - (the file is not a comma version, -and- the file pattern has not been explicitly excluded):
                    #
                    if ($ARG{'F'}  ||  ($fn !~ /,\d+/  &&  (! $ARG{'x'}  ||  $fn !~ /$ARG{'x'}/)))
                    {
                        dbg::log (4, "'$fn' - not excluded");

                        if ($ARG{'v'})
                        {
                            $suffix = '';

                            if (-l $fn)
                            {
                                $suffix .= '@';
                            }

                            if (-x $fn)
                            {
                                $suffix .= '*';
                            }


                            if (-T $fn  &&  $ARG{'v'})
                            {
                                $suffix .= '  t';
                            }
                            else
                            {
                                $suffix .= '  b';
                            }
                        }

                        my $ok_to_prt = 0;

                        if (! $ARG{'r'})
                        {
                            $ok_to_prt = 1;
                        }

                        dbg::log (4, "ok_to_prt = $ok_to_prt");

                        if ($ok_to_prt)
                        {
                            if ($ARG{'v'})
                            {
                                print "$indtxt$g_hlc_on$fn$g_hlc_off$suffix\n";
                            }
                            else
                            {
                                print "$new_dir_path$fn\n";
                            }
                        }


                        if ($ARG{'r'}  ||  $ARG{'X'})
                        {
                            systemCommand ($new_dir_path, $fn)
                        }
                    }
                    else
                    {
                        if ($ARG{'v'})
                        {
                            print ("File '$fn' is excluded;\n");
                        }
                    }
                }
            }
        }
    }


    foreach my $fdn (@dirlist) # next print directory names:
    {
        if ((-d $fdn)  &&  ! ($fdn =~ /^\.{1,2}$/))
        {
            # .backup, .git, .svn and *,* are normally not processed.
            if ($ARG{'F'}  ||  $fdn !~ /(,\d+|^\.backup$|^\.svn$|^\.git$)/)
            {
                if ($ARG{'x'}  &&  $fdn =~ /$ARG{'x'}/)
                {
                    $access = " ...";
                }
                elsif (-x $fdn  &&  -r $fdn)
                {
                    $access = "";
                }
                else
                {
                    $access = " (Access denied)";
                }


                if ($ARG{'v'}  &&  ($g_prt_df  ||  $ARG{'f'}))  # cases where we always want to
                {                                               # print the dir:
                    if (-l $fdn)
                    {
                        print "$indtxt$fdn@/$access\n";
                    }
                    else
                    {
                        print "$indtxt$fdn/$access\n";
                    }
                }
                elsif ($g_prt_df  ||  $ARG{'d'})  # cases where we print matching dirnames:
                {
                    if ($ARG{'i'} ? $fdn =~ /$g_re/io : $fdn =~ /$g_re/o)
                    {
                        dbg::log (4, "'$fdn' dir name matched!");

                        if ($ARG{'v'})  # (Implied $g_prt_df=0)
                        {
                            if (-l $fdn)
                            {
                                print "$new_dir_path$fdn@/$access\n";
                            }
                            else
                            {
                                print "$new_dir_path$fdn/$access\n";
                            }
                        }
                        else
                        {
                            if ($g_prt_df  &&  ! $ARG{'r'})
                            {
                                print "$new_dir_path$fdn/$access\n";
                            }
                            else
                            {
                                print "$new_dir_path$fdn$access\n";
                            }
                        }

                        if ($ARG{'r'}  ||  $ARG{'X'})
                        {
                            systemCommand ($new_dir_path, $fdn);
                        }
                    }
                }


                # This is where we decide whether to descend into the current dir:
                # We do if: (1) haven't exceeded the max level, and
                #           (2) directory allows us access, and
                #           (3) we are allowed to follow symbolic links

                dbg::log (4, "(level=$level < g_nlevels=$g_nlevels && ! access=$access || ! (-l FN=$fdn)))?");

                if ($level < $g_nlevels  &&  ! $access  &&  ($ARG{'L'}  ||  ! (-l $fdn)))
                {
                    dbg::log (4, "- Yes: ckDir (new_dir_path=$new_dir_path, FN=$fdn, currentdir=$currentdir):");

                    &ckDir ($new_dir_path, $fdn, $currentdir, $level + 1);
                }
            }
            else
            {
                if ($ARG{'v'})
                {
                    print ("Directory '$fdn' is excluded;\n");
                }
            }
        }
    }

    chdir ("$parent_dir");

    dbg::pop (2, "ckDir");
}

#=========================================================================
# = function: systemCommand
#
sub systemCommand ($$)
{
    my ($path, $fn) = @_;

    dbg::push (2, "systemCommand");

    #print "my (path:$path  fn:$fn)\n";

    my $command = '';
    my $new_fn  = '';

    if ($ARG{'r'})
    {
        # Do a s/search/replace/ operation on the actual found filename using
        # -s and -r parameters as the search and replace parameters:
        $_ = $fn;

        if ($ARG{'i'})
        {
            eval "s#$g_re#$g_repl#io";
        }
        else
        {
            eval "s#$g_re#$g_repl#o";
        }

        $new_fn = $_;
    }


    if ($ARG{'X'})
    {
        # Replace any {/s} parameter with the actual filename (minus the relative path)
        # of the current found file.
        # Replace any {/r} parameter with the replacement filename (minus the relative path)
        # of the current found file, (assuming -r was used, otherwise this parameter will be empty).
        # Replace any {/p} parameter with the actual relative path and filename of the
        # current found file;

        $_ = $ARG{'X'};

        s/{\/s}/$fn/g;
        s/{\/r}/$new_fn/g;
        s/{\/p}/$path$fn/g;

        $command = $_;
    }


    if ($ARG{'X'})
    {
        if ($ARG{'D'})
        {
            print "$command\n";
        }
        else
        {
            shellCmd ($command);
        }
    }
    else
    {
        if ($ARG{'D'})
        {
            print "move (\"$fn\" \"$new_fn\")\n";
        }
        else
        {
            # from File::Copy package:
            move ($fn, $new_fn);
        }
    }

    dbg::pop (2, "systemCommand");
}

#=========================================================================
# = function: shellCmd
#
sub shellCmd ($)
{
    my ($_cmd) = @_;

    dbg::push (2, "shellCmd");

    print "$_cmd\n"  if ($ARG{'v'});

    my $_result = `$_cmd`;

    print "$_result\n"  if ($ARG{'v'});

    dbg::pop (2, "shellCmd");
}

#=========================================================================
# = function: usage
#
sub usage ($)  # 52XX
{
    dbg::push (2, "usage");

    my ($Msg) = @_;

    print ("$Msg\n\n")  if ($Msg);

    open (SELF, $0);

    while (<SELF>)
    {
        print if (/^##/);
    }

    dbg::pop (2, "usage");

    exit (0);
}

#=========================================================================
# Class Dbglog
#
# This class handles indented debug logging for single-threaded programs.
# Note: the debug level checking is "bitwise-or style".
# 1 - ad-hoc debugging
# 2 - function tracing
# 4 - built-in debug printing
#
package dbg;
{
    our $debug    = 0;

    my $cs_level  = 0;  # this is the call stack level, which increases by 1 for each call.
    my @cs_name   = ();
    my $cs_indent = "";

    sub push ($$;$)
    {
        my ($dbg, $name, $param_text) = @_;

        return unless ($dbg & $debug);

        $param_text = ""  unless (defined ($param_text));

        push (@cs_name, $name);

        $cs_level += 1;

        print $cs_indent . ">" . $name . "($param_text)\n";

        $cs_indent .= "| ";
    }

    sub pop ($$;$)
    {
        my ($dbg, $name, $ret_val) = @_;

        return unless ($dbg & $debug);

        $cs_level -= 1;

        my $pushed_name = pop (@cs_name);

        my $msg = "";

        if ($name ne $pushed_name)
        {
            $msg = " dbg::pop() Error: expected $name but got $pushed_name";
        }
        elsif (defined $ret_val)
        {
            $msg = " return '$ret_val'"
        }

        $cs_indent = substr ($cs_indent, 2);

        print $cs_indent . "<" . $pushed_name . "()" . $msg . "\n";
    }

    sub log ($$)
    {
        my ($dbg, $dbg_text) = @_;

        return unless ($dbg & $debug);

        print $cs_indent . $dbg_text . "\n";
    }

    #=========================================================================
    # Function:   print_hash
    #
    # Description:
    #    Print out the contents of a hash table in key sorted order
    #    Associative Array must be passed in via the * prefix, not %.
    #
    # Usage:
    #    $dbg      Debug level required to print
    #    $Name     Printable name for the hash table.
    #    $HTRef    Reference to the hash table.  (e.g. \%hashtable)
    #    $Chop     1 to chop $value before printing
    #    $VSort    1 to sort by value (not key) (No nested tables)
    #    $Indent   Nbr of spaces to indent table
    #    $Type     '@' if value is an ArrayRef, '%' if value is a HashRef.
    #              '=' is hybrid table in which all elements are ArrayRefs
    #                  except the element for key '=', which is a HashRef.
    #
    # Return Values:
    #    None.
    sub print_hash
    {
        my ($dbg, $Name, $HTRef, $Chop, $VSort, $Indent, $Type) = @_;

        return unless ($dbg & $debug);

        $Chop   = ''  unless defined ($Chop);
        $VSort  = ''  unless defined ($VSort);
        $Indent = 2   unless defined ($Indent);
        $Type   = ''  unless defined ($Type);

        my ($key, $value, %htt, $list);

        dbg::log ($dbg, "HT %$Name:");

        if ($VSort)
        {
            foreach $key (keys (%$HTRef))
            {
                $value = $$HTRef{$key};
                $htt{$value} = $key;
            }

            foreach $key (sort (keys (%htt)))
            {
                $value = $htt{$key};
                chomp ($value)  if ($Chop);
                dbg::log ($dbg, ' ' x $Indent . "'$key' => '$value'");
            }
        }
        else
        {
            foreach $key (sort (keys (%$HTRef)))
            {
                $value = $$HTRef{$key};

                if ($Type eq '@'  or  ($Type eq '='  and  $key ne '='))
                {
                    dbg::log ($dbg, ' ' x $Indent . "'$key' => ");
                    print_list ($dbg, $value, 0, 0, $Indent + 2);
                }
                elsif ($Type eq '%'  or  ($Type eq '='  and  $key eq '='))
                {
                    dbg::log ($dbg, ' ' x $Indent . "'$key' => ");
                    print_hash ($dbg, "", $value, 0, 0, $Indent + 2);
                }
                else
                {
                    chomp ($value)  if ($Chop);
                    dbg::log ($dbg, ' ' x $Indent . "'$key' => '$value'");
                }
            }
        }
    }

    #=========================================================================
    # Function:   print_list
    #
    # Description:
    #    Print out the contents of a list optionally in sorted order.
    #    List/Array must be passed in via the * prefix, not @.
    #
    #= Usage:
    #    $dbg      Debug level required to print
    #    $Name     Printable name for the hash table.
    #    $ListRef  Reference to a list.  (e.g. \@list)
    #    $Chop     1 to chop $value before printing.
    #    $Sort     1 to sort list.
    #    $Indent   Nbr of spaces to indent table
    #    $Type     '@' if value is an Array, '%' if value is a Hash.
    #
    # Return Values:
    #    None.
    sub print_list
    {
        my ($dbg, $Name, $ListRef, $Chop, $Sort, $Indent, $Type) = @_;

        return unless ($dbg & $debug);

        my ($value, $i);

        $Chop   = ''  unless defined ($Chop);
        $Sort   = ''  unless defined ($Sort);
        $Indent = 2   unless defined ($Indent);
        $Type   = ''  unless defined ($Type);

        dbg::log ($dbg, "List \@$Name:");

        if ($Sort)
        {
            foreach $value (sort (@$ListRef))
            {
                chomp  if ($Chop);
                dbg::log ($dbg, ' ' x $Indent . "'$value'");
            }
        }
        else
        {
            $i = 0;  # Array index
            foreach $value (@$ListRef)
            {
                if ($Type eq '@')
                {
                    dbg::log ($dbg, ' ' x $Indent . "[$i] =");
                    print_list ($dbg, $value, 0, 0, $Indent + 2);
                }
                elsif ($Type eq '%')
                {
                    dbg::log ($dbg, ' ' x $Indent . "[$i] =");
                    print_hash ($dbg, "", $value, 0, 0, $Indent + 2);
                }
                else
                {
                    chomp ($value)  if ($Chop);
                    dbg::log ($dbg, ' ' x $Indent . "[$i] = '$value'");
                }

                $i++;
            }
        }
    }
} # end package dbg

#=========================================================================
#=========================================================================

# Check arg list for special flags:
for my $arg (@ARGV)
{
    $dbg::debug   = ($arg =~ /^\d$/  ?  $arg  :  -2)  if ($dbg::debug == -1);

    $dbg::debug   = -1  if ($arg eq '-V');

    $g_shell_args =  0  if ($arg eq '-z');

    $g_repl       =  1  if ($arg eq '-r');  # in the event -r '' given
}

die "Error: -V requires a numeric argument"  if ($dbg::debug < 0);

# Run program:
::main ();

#=========================================================================
#=========================================================================

__END__

